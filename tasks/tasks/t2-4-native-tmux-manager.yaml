id: t2-4-native-tmux-manager
title: 'T2.4: Concrete LXC-Integrated PTY & Tmux Manager'
project_id: dash-terminal
phase_id: p2-core-functionality
status: todo
priority: critical
reporter: dppm-user
created: "2025-09-25"
updated: "2025-09-25"
first: "go through this task description and make a complete local tasklist before you start."
completion: "completion is set by status: done"
dependency_ids: ["t2-2-lxc-manager", "t1-4-tmux-websocket-protocol"]
description: |
  ## T2.4: Concrete LXC-Integrated PTY & Tmux Manager

  **GOAL:** Implement the non-mocked backend logic that executes tmux and PTY commands *inside* a specified LXC container. This task closes the critical integration gap between container management and terminal emulation.

  **CONCRETE REQUIREMENTS:**

  **1. LXC Command Execution:**
     - This manager MUST use the `lxc-manager` (from T2.2) for all shell commands.
     - A new function, `lxc.Exec(containerId, command, args...)`, MUST be implemented in the LXC manager if not present.
     - All interactions with tmux (`list-sessions`, `send-keys`, etc.) MUST be executed via `lxc.Exec`.

  **2. PTY-over-LXC Implementation:**
     - The function to create a new terminal session MUST NOT spawn a local PTY.
     - It MUST use `lxc.Exec` to start a new `tmux` session with a shell *inside the target container*.
     - This process running inside the container is the PTY that will be streamed to the frontend.

  **3. State Management:**
     - The backend MUST maintain a state that maps a WebSocket client to both a `container_id` and a `tmux_session_id`.
     - All functions MUST use the `container_id` from the client's state to target the correct container for every operation.

  **4. Message Handling:**
     - `session_list`: Must execute `tmux list-sessions` *inside the specified container*.
     - `terminal_input`: Must execute `tmux send-keys` *to the correct session inside the correct container*.

  **VERIFICATION (UdfÃ¸rlig Test - No Mocks):**
  - An integration test (`manager_integration_test.go`) MUST be written to verify the entire backend flow against a real, running LXC container.
  - **Test Plan:**
    1.  **Setup:** The test MUST verify a target LXC container is running. It can create a temporary tmux session inside it for the test (`lxc-attach <cid> -- tmux new-session -d`).
    2.  **Connect:** A Go WebSocket client connects to the server.
    3.  **List LXC:** Send `lxc_list` and assert the target container is in the response.
    4.  **List Tmux in LXC:** Send `session_list` with the target `container_id`.
    5.  **Assert:** The response contains the temporary tmux session created in step 1.
    6.  **Execute in LXC:**
        - Send `terminal_input` with the command `touch /tmp/gemini_concrete_test.txt
`.
        - After a short delay, use `lxc-attach <cid> -- ls /tmp/gemini_concrete_test.txt`.
        - **Assert:** The command succeeds, proving the file was created *inside the container*.
    7.  **Teardown:** Clean up the test file and the tmux session inside the container.

  **ðŸŽ¯ SUCCESS CRITERIA:**
  - Zero commands are executed on the host OS. All PTY and tmux operations are delegated to the specified LXC container.
  - The system can manage multiple clients connected to different tmux sessions in different LXC containers simultaneously.
  - The integration test passes, providing concrete proof that the PWA-to-LXC-to-Tmux loop is fully functional.
